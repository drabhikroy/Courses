---
title: "Pivoting and Measuring Confidence"
linktitle: "EDP 613"
author: "Week 8"
output: 
 xaringan::moon_reader:
   css: xaringan-themer.css
   nature:
     ratio: 16:9
     highlightStyle: github
     highlightLines: true
     xcountIncrementalSlides: false
     navigation:
         scroll: false
---

<style>
section {
    display: flex;
    display: -webkit-flex;
}

section p {
    margin: auto;
}

.hljs-github .hljs {
    background: transparent;
    color: #b2dfdb;
}

.hljs-github .hljs-keyword {
    color: #64b5f6;
}

.hljs-github .hljs-literal {
    color: #64b5f6;
}

.hljs-github .hljs-number {
    color: #64b5f6;
}

.hljs-github .hljs-string {
    color: #b7b3ef;
}

section {
    height: 600px;
    width: 60%;
    margin: auto;
    border-radius: 20px;
    background-color: #212121;
}

section p {
    text-align: center;
    font-size: 30px;
    background-color: #212121;
    border-radius: 20px;
    font-family: Roboto Condensed;
    font-style: bold;
    padding: 15px;
    color: #bff4ee;
}

#center {
text-align: center;
}

.center p {
  margin: 0;
  position: absolute;
  top: 50%;
  left: 50%;
  -ms-transform: translate(-50%, -50%);
  transform: translate(-50%, -50%);

</style>

```{r setup, include=FALSE, purl=FALSE}
knitr::opts_chunk$set(echo = FALSE)

library(tidyverse)
library(ggplot2movies)
library(mosaic)
library(flipbookr)
library(patchwork)
library(knitr)
library(kableExtra)
library(fontawesome)
library(here)
library(DT)
library(scales)
library(latex2exp)
library(tweetrmd)
library(showtext)
font_add_google("Roboto Condensed", "roboto")
showtext_auto()
```

```{r echo = FALSE, purl=FALSE}
xaringanthemer::style_duo(
  primary_color = "#212121",
  secondary_color = "#f4eebf",
  code_inline_background_color = "transparent",
  code_inline_color = "#b2dfdb",
  code_highlight_color = "#db6464",
  table_row_border_color = "#212121",
  table_row_even_background_color = "#212121",
  footnote_font_size = "0.6em",
  header_font_google = xaringanthemer::google_font("Roboto Condensed", "700"),
  text_font_google   = xaringanthemer::google_font("Roboto Condensed", "400")
)

xaringanExtra::use_xaringan_extra(c("tile_view", "animate_css", "tachyons"))

xaringanExtra::use_logo(
  image_url = here::here("static", "img", "course_hex_alpha.png"),
  link_url = "https://edp613.asocialdatascientist.com",
  position = xaringanExtra::css_position(top = "1em", right = "1em")
  )
```

# Packages needed and a Note about Icons

Please load up the following packages. Remember to first install the ones you don't have.
```{r echo = TRUE, eval = FALSE, message=FALSE}
library(tidyverse)
library(mosaic)
library(ggplot2movies)
``` 

You may come across the following icons. The table below lists what each means.
```{r eval = TRUE, echo = FALSE, purl=FALSE}
forward <- as.character(fontawesome::fa("forward", fill = "
#4682b4"))

stop <- as.character(fontawesome::fa("stop", fill = "#ff6347"))

link <- as.character(fontawesome::fa("link", fill = "#5cb85c"))

bookmark <- as.character(fontawesome::fa("bookmark", fill = "#faffbd"))


icon_desc <- tibble(
  
  Icon = c(forward,
           stop, 
           link,
           bookmark),
  
  Description = c("Indicates that an example continues on the following slide.",
                  "Indicates that a section using common syntax has ended.",
                  "Indicates that there is an active hyperlink on the slide.",
                  "Indicates that a section covering a concept has ended.")
  
)
```

```{r message=FALSE, warning=FALSE, eval = TRUE, echo = FALSE, purl=FALSE}
kable(icon_desc, 
      escape = FALSE,
      align = 'cl') %>%
  kable_styling(full_width = FALSE) %>%
  column_spec(1, width = "10em") %>%
  column_spec(2, width = "40em") %>%
  row_spec(0, background = "transparent") %>%
  row_spec(1, background = "#transparent") %>%
  row_spec(2, background = "#transparent") %>%
  row_spec(3, background = "#transparent") %>%
  row_spec(4, background = "#transparent") 
```

---

# What is a confidence interval?

A *confidence interval* (CI) gives a range of possible values for a parameter.  It depends on a specified _confidence level_ with 

--

- higher confidence levels corresponding to wider confidence intervals

--

- lower confidence levels corresponding to narrower confidence intervals.  

--

The most common confidence levels include 90%, 95%, and 99%.

---

# Problems with how confidence intervals are taught

You were just taught about the confidence interval in an bad way! 

--

- Finding confidence intervals for some mean is to first assume a normal curve for a population and then magic

--

- But assuming normality is a BIG assumption!

---

# Bootstrapping

--

Hypothesis testing

>- We simply want to if our $H_0$ or $H_1$ is correct.

--

>- First step in being able to generalize

--

<br>
Typically we have a sample of a populationâ€™s data so we can

1. take repeated samples from a sample data of size whatever

--

2. calculate the mean for each of these samples

--

3. created a new distribution of these means

--

4. estimate the population distribution 

<center>
aka <i>bootstrapping</i>
</center>

--

<ol start=5>
<li>calculate the confidence interval (CI)  
</ol>

---

# ggplot2movies

We'll look at CIs, but first let's look at the `ggplot2movies` data set...

```{r echo = TRUE, eval = TRUE}
head(movies)
```

---

...its size...

```{r echo = TRUE, eval = TRUE}
dim(movies)
```

That's 58,788 rows by 24 columns!

---

... and the names of its columns.

```{r echo = TRUE, eval = TRUE}
names(movies)
```

You can see more about the functionality by looking at its [documentation](https://cran.r-project.org/web/packages/ggplot2movies/ggplot2movies.pdf). For now, here's what the variables mean:

- **title**. Title of the movie.
- **year**. Year of release.
- **budget**. Total budget (if known) in US dollars
- **length**. Length in minutes.
- **rating**. Average IMDB user rating.
- **votes**. Number of IMDB users who rated this movie.
- **r1-10**. Multiplying by ten gives percentile (to nearest 10%) of users who rated this movie a 1.
- **mpaa**. [MPAA rating](https://www.motionpictures.org/film-ratings/).
- **Action**, **Animation**, **Comedy**, **Drama**, **Documentary**, **Romance**, **Short**. Binary variables representing if movie was classified as belonging to that genre.

.right[`r fa("link", fill = "#5cb85c")`]

---

# Descriptives 

Let's take a look at a bar chart of the genres. But wait, those are in a bunch of columns and R likes its data in long form! To get the data set to this form, let's first select the columns we need and then use a command called `pivot_longer` which emulates a pivot table in Excel. 

```{r sw1, include = FALSE}
ggplot2movies::movies %>%
  select(Action, Animation, Comedy,
         Drama, Documentary, Romance, 
         Short) %>%
  pivot_longer(
    everything(),
    names_to = "genre"
  )
```
`r chunk_reveal(chunk_name = "sw1", color = c("white", "white", "white"), widths = c(85, 115))`

.right[`r fa("forward", fill = "#4682b4")`]

---

```{r echo = FALSE, eval = TRUE}
select_movies <- 
  ggplot2movies::movies %>%
  select(Action, Animation, Comedy, Drama, Documentary, Romance, Short) %>%
  pivot_longer(
    everything(),
    names_to = "genre"
  )
```

In instances where we have to go from a 

- <span style="color:#b85cb8">long</span> to <span style="color:#5cb85c">wide</span> data set, we'd use a command called `pivot_wider`

- <span style="color:#5cb85c">wide</span> to <span style="color:#b85cb8">long</span> data set, we use a command called `pivot_longer`

.footnote[For more information, take a look at this fantastic overview courtesy of [R-Ladies Sydney](https://rladiessydney.org/courses/ryouwithme/02-cleanitup-4/). For an advanced walkthrough, the [Data Wrangling](https://dcl-wrangle.stanford.edu/pivot_basic.html) site over at Stanford is a great resource.] 
.right[`r fa("link", fill = "#5cb85c")`]

---

# pivot_longer

It is pretty rare that at this stage in your academic development that you need to go from long to wide so we'll be concentrating on the converse with `pivot_longer`. 

.footnote[The original graphics here were created by RStudio's [Allison Hill](https://alison.rbind.io/). I have amended them for aesthetic purposes]

OK let's begin!

.right[`r fa("link", fill = "#5cb85c")`] 
.right[`r fa("forward", fill = "#4682b4")`]

---

# An overview of `pivot_longer` 

We'll concentrate one two options in `pivot_longer`: `names_to` and `values_to`. 

```{r, echo = FALSE, out.height="55%", fig.height=1, out.width="55%", fig.align='center'}
knitr::include_graphics("img/pl2.png")
```

Remember you can always run `?` in front of any command in the Console to get more information about it. For `pivot_longer`, we would simply type in

```{r echo = TRUE, eval = FALSE}
?pivot_longer
```

to see other options. 
.right[`r fa("forward", fill = "#4682b4")`]

---

If you want to follow along with the fake data set we'll be using, run the following command to build the tibble

```{r echo = TRUE, eval = TRUE}
juniors_multiple <- 
  tribble(
  ~ "baker", ~"cinnamon_1", ~"cardamom_2", ~"nutmeg_3",
  "Emma", 1L,   0L, 1L,
  "Harry", 1L,   1L, 1L, 
  "Ruby", 1L,   0L, 1L, 
  "Zainab", 0L, NA, 0L
)
```

and check it just to make sure

```{r echo = TRUE, eval = TRUE}
juniors_multiple
```

Looks good! Let's convert this!
.right[`r fa("forward", fill = "#4682b4")`]

---

To remind you of what the `juniors_multiple` data frame looks like, we have

```{r echo = FALSE, eval = TRUE}
juniors_multiple %>% 
  knitr::kable() %>%
  kableExtra::row_spec(0, background = "#212121") %>%
  kableExtra::row_spec(2, background = "#212121") %>%
  kableExtra::row_spec(4, background = "#212121") 
```

We can assign names to the eventual columns using `names_to` and `values_to`.

```{r, echo = FALSE, out.height="55%", fig.height=1, out.width="55%", fig.align='center'}
knitr::include_graphics("img/pl3.png")
```
.right[`r fa("forward", fill = "#4682b4")`]

---

```{r echo = FALSE, eval = TRUE}
juniors_multiple %>% 
  knitr::kable() %>%
  kableExtra::row_spec(0, background = "#212121") %>%
  kableExtra::row_spec(2, background = "#212121") %>%
  kableExtra::row_spec(4, background = "#212121") 
```

We can assign names to the eventual columns using `names_to` and `values_to`.

```{r, echo = FALSE, out.height="55%", fig.height=1, out.width="55%", fig.align='center'}
knitr::include_graphics("img/pl4.png")
```
.right[`r fa("forward", fill = "#4682b4")`]

---

```{r echo = FALSE, eval = TRUE}
juniors_multiple %>% 
  knitr::kable() %>%
  kableExtra::row_spec(0, background = "#212121") %>%
  kableExtra::row_spec(2, background = "#212121") %>%
  kableExtra::row_spec(4, background = "#212121") 
```

Here you can see the first column `cinnamon_1` and its value `1` associated with the first row `Emma` becomes our first two values under the two columns `spice` and `correct` for our pivoted data frame.

```{r, echo = FALSE, out.height="55%", fig.height=1, out.width="55%", fig.align='center'}
knitr::include_graphics("img/pl5.png")
```
.right[`r fa("forward", fill = "#4682b4")`]

---

This pattern continues until a whole row is used up.

```{r, echo = FALSE, out.height="75%", fig.height=1, out.width="75%", fig.align='center'}
knitr::include_graphics("img/pl6.png")
```

.right[`r fa("forward", fill = "#4682b4")`]

---

Then it repeats for the next row of values...

```{r, echo = FALSE, out.height="30%", fig.height=1, out.width="30%", fig.align='center'}
knitr::include_graphics("img/pl7.png")
```

```{r, echo = FALSE, out.height="30%", fig.height=1, out.width="30%", fig.align='center'}
knitr::include_graphics("img/pl8.png")
```

```{r, echo = FALSE, out.height="30%", fig.height=1, out.width="30%", fig.align='center'}
knitr::include_graphics("img/pl9.png")
```
.right[`r fa("forward", fill = "#4682b4")`]

---

...and so forth...

```{r, echo = FALSE, out.height="30%", fig.height=1, out.width="30%", fig.align='center'}
knitr::include_graphics("img/pl10.png")
```

```{r, echo = FALSE, out.height="30%", fig.height=1, out.width="30%", fig.align='center'}
knitr::include_graphics("img/pl11.png")
```

```{r, echo = FALSE, out.height="30%", fig.height=1, out.width="30%", fig.align='center'}
knitr::include_graphics("img/pl12.png")
```
.right[`r fa("forward", fill = "#4682b4")`]

---

...until we run out of rows...

```{r, echo = FALSE, out.height="30%", fig.height=1, out.width="30%", fig.align='center'}
knitr::include_graphics("img/pl13.png")
```

```{r, echo = FALSE, out.height="30%", fig.height=1, out.width="30%", fig.align='center'}
knitr::include_graphics("img/pl14.png")
```

```{r, echo = FALSE, out.height="30%", fig.height=1, out.width="30%", fig.align='center'}
knitr::include_graphics("img/pl15.png")
```
.right[`r fa("forward", fill = "#4682b4")`]

---

...and get the final table of pivoted values.

```{r, echo = FALSE, out.height="75%", fig.height=1, out.width="75%", fig.align='center'}
knitr::include_graphics("img/pl16.png")
```

.right[`r fa("forward", fill = "#4682b4")`]

---

We can even amend the current command to include things like `order`!

```{r, echo = FALSE, out.height="75%", fig.height=1, out.width="75%", fig.align='center'}
knitr::include_graphics("img/pl17.png")
```

.right[`r fa("stop", fill = "#ff6347")`]

---

# Shortcut

Rather than accounting for every column, you can just tell R not to account for columns
```{r echo = TRUE, eval = TRUE}
juniors_multiple %>%
  pivot_longer(-baker,
                names_to = c('spice', 'order'),
                names_sep = '_',
                values_to = 'correct')
```

---

# Single column types

`pivot_wider` is great for columns of the same type. For example, if we run 

```{r echo = TRUE, eval = TRUE}
glimpse(juniors_multiple)
```

all we have are integers... 

---

# Multiple column types

... but for the following

```{r echo = TRUE, eval = TRUE}
juniors_multiple_full <- 
  tribble(
  ~ "baker", ~"score_1", ~"score_2", ~"score_3", 
  ~ "guess_1", ~"guess_2", ~"guess_3",
    "Emma", 1L, 0L, 1L, "cinnamon", "cloves", "nutmeg",
    "Harry", 1L,  1L, 1L, "cinnamon", "cardamom", "nutmeg",
    "Ruby", 1L, 0L, 1L, "cinnamon", "cumin", "nutmeg",
    "Zainab", 0L, NA, 0L, "cardamom", NA_character_, "cinnamon"
  )
```

```{r echo = TRUE, eval = TRUE}
juniors_multiple_full
```

.right[`r fa("forward", fill = "#4682b4")`]
---

```{r echo = TRUE, eval = TRUE}
glimpse(juniors_multiple_full)
```

...we have both character and numeric vectors.

---

Try running the following

```{r echo = TRUE, eval = FALSE}
juniors_multiple_full %>% 
  pivot_longer(score_1:guess_3,
               names_to = c('score', 'guess'),
               names_sep = "_",
               values_to = 'correct')
```

Do you get `Error: Can't combine score_1 <integer> and guess_1 <character>.`? So what can you do?

Well since computers are stupid, you have to tell R what to look for.

---

# Generalizing

We can actually just tell R to treat all values the same.
```{r sw2, include = FALSE}
juniors_multiple_full %>% 
  # Don't do anything with the baker column
    pivot_longer(-baker, 
  # Treat all columns the same and order them
                 names_to = c(".value", "order"), 
  # Control how the column names are broken up
                 names_sep = "_")
```

`r chunk_reveal(chunk_name = "sw2", color = c("white", "white", "white"), widths = c(120, 100))`

---

# Back to the bar chart

Now that we know how to pivot, we can just `group_by` genre type and then `tally`
```{r sw3, include = FALSE}
ggplot2movies::movies %>%
  select(Action, Animation, Comedy,
         Drama, Documentary, Romance, 
         Short) %>%
  pivot_longer(everything(),
               names_to = "genre") %>%
  group_by(genre) %>%
  dplyr::tally(value)
```

`r chunk_reveal(chunk_name = "sw3", color = c("white", "white", "white"), widths = c(90, 120))`

.right[`r fa("stop", fill = "#ff6347")`]

---

```{r}
movies_by_genre <-
  ggplot2movies::movies %>%
  select(Action, Animation, Comedy,
         Drama, Documentary, Romance, 
         Short) %>%
  pivot_longer(everything(),
               names_to = "genre") %>%
  group_by(genre) %>%
  dplyr::tally(value)
```

---

```{r sw4, include = FALSE}
ggplot(movies_by_genre,
       aes(x = genre, 
           y = n, 
           fill = -n)) +
  geom_bar(stat='identity', 
           show.legend = FALSE) +
  labs(title = "Count of Genre", 
       x = "Genre", 
       y = "Count") +
  theme_minimal()
```

`r chunk_reveal(chunk_name = "sw4", color = c("white", "white", "white"), widths = c(100, 100))`

---

# Back to the movies

Let's take a look at the ratings

```{r sw5, include = FALSE}
ggplot2movies::movies %>% 
  ggplot(aes(x = rating)) +
  geom_histogram(aes(fill = -..count..),
                 color = "white",
                 bins = 30,
                 show.legend = FALSE) +
  theme_minimal()
```

`r chunk_reveal(chunk_name = "sw5", color = c("white", "white", "white"), widths = c(95, 115))`

---

```{r echo = TRUE, eval = TRUE, fig.asp = 0.75, fig.width = 5, fig.align="center"}
pop <- 
  ggplot2movies::movies %>% 
  ggplot(aes(x = rating)) +
  geom_histogram(aes(fill = -..count..),
                 color = "white", 
                 bins = 30,
                 show.legend = FALSE) +
  theme_minimal() +
  ggtitle("Population")
```

---

# Purpose

We would like to produce a confidence interval for the population mean rating. Let's first pretend we had to take a sample of $n=70$ from the $N= 58788$ movies. To do this, we'll use the `sample_n` command from the `dplyr` package.

```{r echo = TRUE, eval = TRUE}
set.seed(999) # Random number generator

movies_sample <- 
  ggplot2movies::movies %>% 
  sample_n(70)
```

---

Let's see what this looks like

```{r sw7, include = FALSE}
ggplot(movies_sample, 
       aes(x = rating)) +
       geom_histogram(aes(fill = -..count..),
                      color = "white", 
                      bins = 30,
                      show.legend = FALSE) +
       theme_minimal()
```

`r chunk_reveal(chunk_name = "sw7", color = c("white", "white", "white"), widths = c(120, 100))`

---

# Population Estimation

--

- The histogram is an estimate of our population distribution histogram

--

To estimate a range of values, we use the mean of the sample 

```{r echo = TRUE, eval = TRUE}
(movies_sample_mean <- 
   movies_sample %>% 
   summarize(mean = mean(rating)))
```

.footnote[A good way to to this is to add parentheses around a variable]

--

- This is a single estimation. 

--

- Earlier you sampled from the population - aka **sampling with replacement**. 

.right[`r fa("forward", fill = "#4682b4")`]

---

# Sampling with Replacement

To do this, we can use the `resample` command from the `mosaic` package:

```{r sw8, include = FALSE}
resample(movies_sample) %>%
  arrange(orig.id) %>% 
  summarize(mean = mean(rating))
```

`r chunk_reveal(chunk_name = "sw8", color = c("white", "white", "white"), widths = c(100, 100))`

---

This is only one sample mean!

---

To do a whole bunch we can run a `do` command with parentheses like so

```{r sw9, include = FALSE}
do(10) * 
  (resample(movies_sample) %>% 
     summarize(mean = mean(rating)))
```

`r chunk_reveal(chunk_name = "sw9", color = c("white", "white", "white"), widths = c(100, 100))`

.right[`r fa("forward", fill = "#4682b4")`]

---

But a sample of 10 is so lame. Let's think big and try 10000!

--

```{r echo = TRUE, eval = TRUE}
not_lame <- 
  do(10000) * summarize(resample(movies_sample), 
                        mean = mean(rating))
```

...wait a bit

---

# Estimating the population

```{r sw10, include = FALSE}
ggplot(data = not_lame , 
       mapping = aes(x = mean)) +
  geom_histogram(aes(fill = -..count..),
                 color = "white",
                 bins = 30, 
                 show.legend = FALSE) +
  theme_minimal()
```

`r chunk_reveal(chunk_name = "sw10", color = c("white", "white", "white"), widths = c(110, 110))`

---

```{r echo = TRUE, eval = TRUE}
samp <- 
  ggplot(data = not_lame , 
       mapping = aes(x = mean)) +
  geom_histogram(aes(fill = -..count..),
                 color = "white",
                 bins = 30,
                 show.legend = FALSE) +
  theme_minimal() +
  ggtitle("Sample")
```

---

# Comparison

```{r echo = FALSE, eval = TRUE, fig.asp = 0.6, fig.width = 10, fig.align='center'}

samp + pop

```

---

# Confidence using **quantiles**

 **quantiles** are

--

- cut points dividing the range of a probability distribution into continuous intervals with equal probabilities

--

- found by isolating the middle 95% of values which corresponds to a 95% confidence interval for the population mean rating

--

```{r echo = TRUE, eval = TRUE}
(ci95_mean <- confint(not_lame, 
                      level = 0.95, 
                      method = "quantile"))
```

--

- we can be 95% confident that the true mean rating of ALL IMDB ratings is between 5.49 and about 6.13

---

# Confidence using **standard error**

**standard error** is

--

- the standard deviation of the sampling distribution 

--

- approximated by the bootstrap distribution or the null distribution depending on the context.

--

```{r echo = TRUE, eval = TRUE}
(ci95_mean <- confint(not_lame, 
                      level = 0.95, 
                      method = "stderr"))
```

--

- we can be 95% confident that the true mean rating of ALL IMDB ratings is between 5.49 and about 6.13

---

## Thats it!

<center>
```{r tweet, echo = FALSE, eval = TRUE, out.height="30%", out.width="30%", purl=FALSE}
tweet_embed("https://twitter.com/allison_horst/status/1190001300622036992",
            maxwidth = 75,
            theme = "dark",
            plain = TRUE)
```
</center>

